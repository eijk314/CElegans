<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8 />
	<title></title>
	<link rel="stylesheet" type="text/css" media="screen" href="css/master.css" />
    <link href='http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz' rel='stylesheet' type='text/css'>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
	<!--[if IE]>
		<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
</head>
<body>
	<div class='title'>Visualizing a Worm's Nervous System <br/> 
        <a id='wiki' href="https://en.wikipedia.org/wiki/Caenorhabditis_elegans" target='_blank'>C. Elegans </a>
        <div class='celegans'></div>
    </div>
    <div class='legend'>
        <b>Neuronal Regions</b><br/>
        <div class='color H'></div> Head<br/>
        <div class='color M'></div> Body<br/>
        <div class='color T'></div> Tail<br/><br/>
        Each circle represents a neuron. It's size is representative of the neuron's number of synapses.<br/>
        Each grey line represents the number of total connections from one region to another through their thickness.<br/><br/>
        Placing the cursor over one of them reveals the neuron's name and position in the body of the C. Elegans,
        shown in the diagram below.<br/><br/>
        
        A short inspection of the graph shows us two important pieces of information:<br/>
        1. the head contains most of the neurons, and is home for the most complex of them. <br/>
        2. there are two main neural pathways: <br/>
        <t/>a. from head to body, presumably to control movement.<br/>
        <t/>b. from tail to head, to give feedback during the sexual processes.
    </div>
    <div class='elegans'>
        <div class='neuron'></div>
        <div class='over'></div>
    </div>
    <div class='graph'></div>
    <div class='citation'>
        <b>Data taken from:</b><br/>
        Oshio, K., Iwasaki, Y., Morita, S., Osana, Y., Gomi, S., Akiyama, E.,<br/>
        Omata, K., Oka, K. and Kawamura, K. (2003).<br/>
        "Database of Synaptic Connectivity of C. elegans for Computation",<br/>
        Technical Report of CCeP, Keio Future, No.3, Keio University.
    </div>
    <script type="application/javascript">
        $('.celegans').on('click', function(){
            $('#wiki').click();
        })
        // C. Elegans map
        mapW = 600, mapH = 130;
        map = d3.select(".elegans")
            .append("svg")
                .attr("width", mapW)
                .attr("height", mapH);
        drawMap = map.append("g")
            .attr("transform", "translate(0,0)");
        
        // Graph size and margins
        var margin  = 30;
        var width   = parseInt(d3.select(".graph").style("width" )) - margin * 2,
            height  = parseInt(d3.select(".graph").style("height")) - margin * 2,
            padding = 6, // separation between nodes
            maxRadius = 8;

        var regions = 3;
        
        var x = d3.scale.ordinal()
            .domain(d3.range(regions))
            .rangePoints([0, width], 1);

        var svg = d3.select(".graph").append("svg")
            .attr("width", width)
            .attr("height", height);
        
        function neurinfo(d){
            return '<b>' + d.neuron + '</b> Neuron connections [to, from]:' + 
            '    HEAD [' + d.sh +
            ', ' + d.rh +
            ']    BODY [' + d.sm +
            ', ' + d.rm +
            ']    TAIL [' + d.st +
            ', ' + d.rt +']';
        }
        
        function collide(node) {
            var r = node.radius + 18,
            nx1 = node.x - r,
            nx2 = node.x + r,
            ny1 = node.y - r,
            ny2 = node.y + r;
            return function(quad, x1, y1, x2, y2) {
                if (quad.point && (quad.point !== node)) {
                    var x = node.x - quad.point.x,
                    y = node.y - quad.point.y,
                    l = Math.sqrt(x * x + y * y),
                    r = node.radius + quad.point.radius + 2;
                    if (l < r) {
                        l = (l - r) / l * .5;
                        node.x -= x *= l;
                        node.y -= y *= l;
                        quad.point.x += x;
                        quad.point.y += y;
                    }
                }
                return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
            };
        }
        
        // load the data
        d3.json("data/elegans.json", function(error, graph) {
            if (error) throw error;
            
            var HtM = 0, HtT = 0, MtH = 0, 
                MtT = 0, TtM = 0, TtH = 0, 
                HtH = 0, MtM = 0, TtT = 0;
            
            graph.nodes.forEach(function(d){
                switch(d.region){
                    case 'H' :
                        HtH += d.sh;
                        HtM += d.sm;
                        HtT += d.st;
                        break;
                    case 'M' :
                        MtH += d.sh;
                        MtM += d.sm;
                        MtT += d.st;
                        break;
                    case 'T' :
                        TtH += d.sh;
                        TtM += d.sm;
                        TtT += d.st;
                        break;
                }
            });
            
            function makechord(d, xs, ys, xe, ye){
                return svg.append("path")
                    .attr("d", "M" + (xs) + "," + (ys + d/2)
                        + "L" + (xs) + "," + (ys - d/2)
                        + "L" + (xe) + "," + (ye - d/4)
                        + "L" + (xe) + "," + (ye + d/4)
                        + "C")
                    .style("fill", '#888');
            }
            
            LHtM = makechord(HtM/10, x(0)+310, height/2 - 40, x(1)-50, height/2 - 40);
            LMtJ = makechord(MtH/10, x(1)-50, height/2 + 40, x(0)+310, height/2 + 40);
            LMtT = makechord(MtT/10, x(1)+150, height/2 - 40, x(2)-200, height/2 - 40);
            LTtM = makechord(TtM/10, x(2)-200, height/2 + 40, x(1)+150, height/2 + 40)
            
            function makecurve(d, xs,ys, xm,ym, xe,ye){
                var delta = (xs < xe) ? 20 : -20 ; 
                return svg.append("path")
                    .attr("d", "M" + (xs) + "," + (ys - d/2)
                        + "L" + (xs) + "," + (ys - d/2)
                        + "S" + (xm) + "," + (ym - d/3) + " " + (xe) + "," + (ye)
                        + "L" + (xe) + "," + (ye)
                        + "S" + (xm+delta) + "," + (ym + d/3) + " " + (xs) + "," + (ys + d/2) + "C"
                    )
                    .style("fill", '#888');
            }
            
            LHtT = makecurve(HtT/10, (x(0)+310),(height/2 - 120) , x(1),(height/2 - 300), (x(2)-200), (height/2 - 80))
            LTtH = makecurve(TtH/10, (x(2)-200),(height/2 + 80) , x(1),(height/2 + 300), (x(0)+310), (height/2 + 80))
            
            var force = d3.layout.force()
                .nodes(graph.nodes)
                .gravity(0.1)
                .size([width, height])
                .start();

            var node = svg.selectAll(".node")
                .data(graph.nodes)
                .enter().append("circle")
                .attr("class", function(d) { return d.region; })
                .attr("cx", function(d){
                    switch(d.region){
                        case 'H' : return x(0);
                        case 'M' : return x(1);
                        case 'T' : return x(2);
                    };
                })
                .attr("cy", height/2)
                .attr("r", function(d) { 
                    d.radius = 4 + d.synapses/20;
                    return d.radius; })
                .style("opacity",0.5)
                .call(force.drag)
                .on("mouseover", function(d){
                    var neuron = d.neuron;
                    d3.select(this).style("opacity",1)
                    drawMap.append("circle")
                        .attr("class", d.region)
                        .attr("cx", parseFloat(d.position*mapW))
                        .attr("cy", parseInt(0.5*mapH))
                        .attr("r", 4 + d.synapses/25);
                    LHtM.remove();
                    LHtM = makechord(d.sm/10, x(0)+310, height/2 - 40, x(1)-50, height/2 - 40);

                    $('.neuron').html(neurinfo(d));
                }).on("mouseout", function(d){
                    d3.select(this).style("opacity",0.5);
                    drawMap.selectAll("circle")
                        .transition()
                        .style("opacity",0)
                        .remove();
                    $('.neuron').html('');
                    
                    LHtM.remove();
                    LHtM = makechord(HtM/10, x(0)+310, height/2 - 40, x(1)-50, height/2 - 40);
                });

            node.append("title")
                .text(function(d) { return d.neuron; });
            
            force.on("tick", function(e) {
                var q = d3.geom.quadtree(graph.nodes),
                    i = 0,
                    n = graph.nodes.length;
                
                var k = .1 * e.alpha;
                
                graph.nodes.forEach(function(o, i) {
                    var dx;
                    switch(o.region){
                        case 'H' : dx = x(0); break;
                        case 'M' : dx = x(1); break;
                        case 'T' : dx = x(2); break;
                    };
                    o.y += (height/2 - o.y) * k;
                    o.x += (dx - o.x) * k;
                });
                
                while (++i < n) q.visit(collide(graph.nodes[i]));
                
                node.attr("cx", function(d) { return d.x; })
                    .attr("cy", function(d) { return d.y; });
           
            });
        });
    </script>
</body>
</html>